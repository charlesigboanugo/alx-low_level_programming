        pall

      push    4 
    pall   
    pall
pop
#include "monty.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <ctype.h>

extern int operand;
extern stack_t *stack;
extern unsigned int size;

static int func_err = 0;

void free_stk(stack_t *stack)
{
	stack_t *ptr;

	if (stack != NULL)
	{
		while (stack != NULL)
		{
			ptr = stack;
			stack = stack->next;
			free(ptr);
		}
	}
}

void print_err(char *errmsg, unsigned int line_num)
{
	fprintf(stderr, "L%u: %s\n", line_num, errmsg);
}

void clean_err_exit(int file, unsigned int line_num)
{
	if (close(file) == -1)
		print_err("", line_num);
	free_stk(topstack);
	exit(EXIT_FAILURE);
}

void pushfunc(stack_t **stack, unsigned int line_num)
{
	print_err("", line_num);
	func_err = -1;
	
}

void pallfunc(stack_t **stack, unsigned int line_num)
{
	print_err("", line_num);
	func_err = -1;

}

void pintfunc(stack_t **stack, unsigned int line_num)
{
	print_err("", line_num);
	func_err = -1;

}

void popfunc(stack_t **stack, unsigned int line_num)
{
	print_err("", line_num);
	func_err = -1;

}

void swapfunc(stack_t **stack, unsigned int line_num)
{
	print_err("", line_num);
	func_err = -1;

}

void addfunc(stack_t **stack, unsigned int line_num)
{
	print_err("", line_num);
	func_err = -1;

}

void nopfunc(stack_t **stack, unsigned int line_num)
{
	print_err("", line_num);
	func_err = -1;

}

int exec_instr(instruction_t *inst, char *opcode, unsigned int line_num)
{
	void (*op_func)(stack_t **stack, unsigned int line_number);
	unsigned int i;

	for (i = 0; i < 7; i++)
	{
		if (strcmp(opcode, inst[i].opcode) == 0) 
			op_func = inst[i].f;
	}

	op_func(&topstack, line_num);

	if (func_err == -1)
		return (-1);
	return (0);
}

int read_trim_line(int file, char **line, unsigned int line_num)
{
	char *ptr, byte;
	ssize_t bytes_read;
	unsigned int index = 0;

	ptr = malloc(sizeof(*ptr) * 99);
	if (ptr == NULL)
	{
		print_err("", line_num);
		return (-1);
	}
	*line = ptr;
	while (byte != '\n' && index < 99)
	{
		bytes_read = read(file, &byte, 1);
		if (bytes_read == -1)
		{
			print_err("", line_num);
			return (-1);
		}
		if (bytes_read == 0)
			break;
		if (byte != ' ' && byte != '\n')
		{
			ptr[index] = byte;
			index++;
		}	
	}
	if (index == 0)
	{
		if (bytes_read == 0)
			return (EOF);
		return (0);
	}
	ptr[index] = '\0';
	return (index);
}

char *get_opcode(char *line_buf, instruction_t *inst, unsigned int line_num)
{
	unsigned int i;

	for(i = 0; i < 7; i++)
	{
		if (strstr(line_buf, inst[i].opcode) == line_buf)
			return (inst[i].opcode);
	}
	print_err("unknown instruction", line_num);
	return (NULL);
}
int *set_operand(char *line_buf, char *opcode, unsigned int line_num)
{
	int sign = 1;
	char *ptr;

	ptr = line_buf + strlen(opcode);
	for (; *ptr != '\0'; ptr++)
	{
		if (*ptr = '-')
			sign *= -1;
		if (isdigit(*ptr))
		{
			operand =  (sign * atoi(ptr));
			return (&operand);
		}
	}
	print_err("", line_num);
	return (NULL);
}
int opcode_req_arg(char *opcode)
{
	if (strcmp(opcode, "push") == 0)
		return 1;
	return (0);
}

/**
* main - an interpreter for monty bytecode file
* @ac: number of arguments
* @ac: program arguments
*
* Return: 0 if successful
*/

int main(int ac, const char **av)
{
	instruction_t inst[7] = {
		{"push", pushfunc}, {"pall", pallfunc},
		{"pint", pintfunc}, {"pop", popfunc},
		{"swap", swapfunc}, {"add", addfunc},
		{"nop", nopfunc}
	};
	int file, byte_read;
	unsigned int line_num = 0;
	char *opcode = NULL, *line = NULL;

	if (ac != 2)
	{
		dprintf(STDERR_FILENO, "USAGE: monty file\n");
		exit(EXIT_FAILURE);
	}

	file = open(av[1], O_RDONLY);
	if (file == -1)
	{
		dprintf(STDIN_FILENO, "Error: Can't open file %s\n", av[1]);
		exit(EXIT_FAILURE);
	}
	
	while (1)
	{
		free(line);
		byte_read = read_trim_line(file, &line, line_num);
		if (byte_read == -1)
			clean_err_exit(file, line_num);
		if (byte_read == EOF)
			break;
		if (byte_read == 0)
		{
			line_num++;
			continue;
		}
		opcode = get_opcode(line, inst, line_num);
		if (opcode == NULL)
			clean_err_exit(file, line_num);
		if (opcode_req_arg(opcode))
		{
			if (set_operand(line, opcode, line_num) == NULL)
				clean_err_exit(file, line_num);
		}
		if (exec_instr(inst, opcode, line_num) == -1)
			clean_err_exit(file, line_num);
		line_num++;
	}
	free(line);
	free_stk(topstack);
	if (close(file) == -1)
		print_err("", line_num);
	return (0);
}
